// This file was generated by the ExaHyPE toolkit.
// It will not be overwritten.
//
//
// ========================
//   www.exahype.eu
// ========================
#include "UpdateMicroscaleMethods.h"

#include "kernels/GaussLegendreBasis.h"

#include "spipack/KineticEquations/KineticModels.hpp"

#include "spipack/ConservationEquations/Boltzmann.hpp"

using namespace muq::SamplingAlgorithms;
using namespace spi::KineticEquations;
using namespace spi::ConservationEquations;

spiEX_Boltzmann::UpdateMicroscaleMethods::UpdateMicroscaleMethods() : exahype::plotters::LimitingADERDG2UserDefined::LimitingADERDG2UserDefined() {}

void spiEX_Boltzmann::UpdateMicroscaleMethods::plotADERDGPatch(const tarch::la::Vector<DIMENSIONS, double>& offsetOfPatch, const tarch::la::Vector<DIMENSIONS, double>& sizeOfPatch, double* const u, double timeStamp) {
  assert(false);
}

void spiEX_Boltzmann::UpdateMicroscaleMethods::plotFiniteVolumesPatch(const tarch::la::Vector<DIMENSIONS, double>& offsetOfPatch, const tarch::la::Vector<DIMENSIONS, double>& sizeOfPatch, double* const u, double timeStamp) {
  assert(states);

  // get the boltzmann solver
  //auto bolt = Boltzmann::BoltzmannSolver();
  auto bolt = spiEX_Boltzmann::BoltzmannSolver::GetBoltzmannSolver();
  assert(bolt);
  assert(bolt->NumberOfParameters==DIMENSIONS);
  assert(bolt->getType()==exahype::solvers::Solver::Type::LimitingADERDG);
  exahype::solvers::FiniteVolumesSolver* fvSolver = bolt->getLimiter().get();
  assert(fvSolver);

  const int numberOfCellsPerAxis = fvSolver->getNodesPerCoordinateAxis();
  dfor(i, numberOfCellsPerAxis+bolt->GhostLayerWidth) {
    if( tarch::la::allSmaller(i, numberOfCellsPerAxis+bolt->GhostLayerWidth) && tarch::la::allGreater(i, bolt->GhostLayerWidth-1) ) {
      // get the coordinate
      Eigen::Matrix<double, DIMENSIONS, 1> loc;
      for( std::size_t j=0; j<DIMENSIONS; ++j ) {
        loc(j) = u[peano::utils::dLinearisedWithoutLookup(i, numberOfCellsPerAxis+2*bolt->GhostLayerWidth)*_variables+bolt->NumberOfVariables+j];
      }

      // get the state at this coordinate
      Eigen::Matrix<double, 1, 1> massDensity;
      Eigen::Matrix<double, MacroscaleInformation::dim, 1> velocity;
      Eigen::Matrix<double, 1, 1> energy;
      massDensity(0) = u[peano::utils::dLinearisedWithoutLookup(i, numberOfCellsPerAxis+2*bolt->GhostLayerWidth)*_variables];
      for( std::size_t j=0; j<DIMENSIONS; ++j ) {
        velocity(j) = u[peano::utils::dLinearisedWithoutLookup(i, numberOfCellsPerAxis+2*bolt->GhostLayerWidth)*_variables+1+j]/massDensity(0);
      }
      energy(0) = u[peano::utils::dLinearisedWithoutLookup(i, numberOfCellsPerAxis+2*bolt->GhostLayerWidth)*_variables+1+DIMENSIONS]/massDensity(0);

      states->Add(std::make_shared<SamplingState>(std::vector<Eigen::VectorXd>({loc, massDensity, velocity, energy})));
    }
  }
}

void spiEX_Boltzmann::UpdateMicroscaleMethods::startPlotting(double time) {
  // reset the current time
  currentTime = time;

  // reset the states
  states = std::make_shared<SampleCollection>();
  assert(states->size()==0);
}

void spiEX_Boltzmann::UpdateMicroscaleMethods::finishPlotting() {
  assert(!std::isnan(currentTime));
  assert(states);
  assert(states->size()>0);

  // get the kinetic models
  auto kineticModels = KineticModels::ExaHyPEKineticModels();
  assert(kineticModels);

  // update the stored fields for the kinetic models
  kineticModels->UpdateFields(currentTime, states);

  std::cout << "finishPlotting---UpdateMicroscaleMethods" << std::endl << std::endl << std::endl;
}
